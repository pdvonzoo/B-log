<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <h1 id="amazonclone">amazon clone</h1>

    <h2 id="1skills">1. Skills</h2>

    <p>HTML | SCSS | Javascript | webpack | Jest</p>

    <h2 id="2">2. 개발 방식</h2>

    <p>
      레벨 2의 마지막 프로젝트인 amazon-clone를 시작하면서 두 가지를 목표로
      삼았다.
    </p>

    <ol>
      <li>지난 프로젝트에서 시도했던 방식 중 좋았던 부분을 더욱 발전시킨다.</li>

      <li>
        시도했던 방식 중 장점을 깨닫지 못했던 부분에 대해서 더 깊이 이해하기
        위해 새로운 방식으로 적용한다.
      </li>
    </ol>

    <h3 id="21">2-1 좋았던 방식</h3>

    <p>
      지난 프로젝트에서 비동기 데이터를 받는 부분에 대해서 for await of를
      사용하여 이터러블한 코드를 구현하였다. 비동기 코드에 대해서 콜백으로
      처리를 했던 방식(실질적으로 비동기를 처리하는 방식은 아니지만)에서
      promise를 활용한 비동기 처리 방식이 더 실용적으로 느껴졌다. 좋았던 이유는
      가독성 부분이나 콜백 중첩을 만들지 않는다는 점도 있지만 무엇보다 제어권을
      가져올 수 있다는 것에 큰 매력을 느꼈다. 그래서 이번 프로젝트에서도
      promise를 활용한 비동기 제어를 하기로 결정했다.
    </p>

    <h3 id="22">2-2 더 깊이 이해하고 싶었던 것</h3>

    <p>
      프로젝트의 마지막 스텝이 테스트 코드였다. unit test를 하면서 기존 코드의
      버그가 정상적으로 작동 하는지를 체크하였다. ~~사실 테스트 코드를 작성하는
      시기엔 이 과정이 마냥 귀찮고 의미를 알 수 없었다...~~ 테스트 코드를
      작성하면서 이 과정에 대한 이점이 무엇인지 알기 위해서 테스트 코드에 관한
      글, 책, 영상을 찾아보았다. 많은 사람들이 견고한 소프트웨어를 만들기 위해서
      반드시 필요한 것이라는 글을 쓰고 말을 했다. 그리고 그 프로젝트가 끝나고
      새로운 프로젝트를 시작하는 시기에 테스트 코드의 진정한 장점이 무엇인지,
      어떻게 작성해야 하는 것인지를 찾아보며 처음으로 TDD(Test
      Driven-Developement)라는 개발 방식을 발견했다. 테스트 코드를 작성한 후
      실제 서비스 코드를 작성하는 방식이 신기했다. 그 이후 jasmine을 활용한
      자바스크립트 테스트 관련 책을 하나 골라서 2번 정도 정독했다. 또 테스트
      코드가 직접 쓰이는 예제들을 분석 해보고 연습해 보았다. 어렴풋하게 테스트
      라이브러리에 대한 이해를 하고 실제 프로젝트 코드를 작성하기 시작했다.
    </p>

    <h2 id="3tdd">3. TDD</h2>

    <p>
      처음 TDD를 시작하며 그 어떤 때보다 설계에 신경을 썼다. 미리 노트에 클래스
      간의 의존 관계를 정의하고 각 클래스의 하는 일을 명확하게 설정했다. 이후
      테스트 코드를 작성하였다. 클래스가 정상적으로 생성되는지, 원하는 타입이
      들어가는지, 콜백 함수가 정상적으로 실행하는지... 그 모든 것들을 다
      커버하기 위해 노력했다. 계속 작업을 이어가면서 가장 처음 느낀 것은
      의미없는 테스트 코드를 너무 많이 작성한다는 것이었다. 테스트 코드를 어떻게
      작성하는 것이 좋은 것일지 고민했다. 가장 신경 쓰였던 부분은 타입 검사
      로직이 너무 비효율적이라는 것이었다. 그래서 타입 체크 시스템을 만들 생각을
      하게 되었다.
    </p>

    <h3 id="31typesystem">3-1 Type system</h3>

    <p>
      타입 스크립트를 쓸 수도 있었겠지만 레벨 2까지는 최대한 라이브러리를
      사용하지 않고 자바스크립트 언어에 대한 더 깊은 이해를 하고 싶었다. 그래서
      인자 값과 반환 값의 타입을 체크하는 라이브러리를 만들었다. 이 시기에는
      클래스의 의존 관계 자체가 낯설어서 시간이 생각보다 오래 걸렸다. 그래도
      클래스의 역할을 명확히 나누고 설계를 완료하였다. 타입을 체크하는 과정에는
      세가지 클래스가 필요했다.
    </p>

    <ol>
      <li>실제 서비스에 사용될 코드가 정의된 클래스</li>

      <li>해당 클래스의 타입을 정의 해두는 클래스</li>

      <li>두번째 클래스와 세번째 클래스를 비교해주는 클래스</li>
    </ol>

    <p>
      이렇게 세가지 클래스를 만들고 인자 값과 반환 값을 비교하여 정의한 타입이
      올바르게 입출력 되는지를 체크했다.
    </p>

    <h3 id="32ui">3-2 UI 테스트</h3>

    <p>
      타입 체크 시스템 구현은 어려운 일이었지만 그만큼 UI 테스트를 하는 것도
      신경쓰이는 부분이었다. 브라우저가 아닌 노드 환경에서 작동하는 코드로
      어떻게 UI 테스트를 할 지 고민이었다. 그러던 중 '<strong>jsdom</strong>'을
      발견했다. 노드 환경에서 DOM의 환경을 구성할 수 있게 도와주는
      라이브러리였는데 해당 라이브러리로 테스트 코드에서 DOM의 변화를 체크 할 수
      있었다.
    </p>

    <p>node 환경에서 돔 핸들링은 아래의 유틸을 이용하여 해결할 수 있었다.</p>

    <pre><code>// test utill
import {JSDOM} = require('jsdom');
import window = new JSDOM();

document = window.document;

function render(html){
    const container = document.createElement("body");
    constainer.innerHtml = html;
    const $getTestEl = document.querySelector(`[data-testid="${testId}"]`);
    const $getTestElAll = document.querySelectorAll(`[data-testid="${testId}"]`);
    return {container, $getTestEl, $getTestElAll}
}
export {render};
</code></pre>

    <h3 id="33asynchronousprocessing">3-3 Asynchronous processing</h3>

    <p>
      비동기 상황을 테스트하기 위해선 HTTP 데이터가 필요했다. 그래서 HTTP mock
      객체를 사용해서 비동기가 정상적으로 실행 되는지 확인할 수 있었다.
    </p>

    <pre><code>const createMockXHR = (responseJSON) =&gt; {
    const mockXHR = {
            open: jest.fn(),
            send: jest.fn(),
            readyState: 4,
            status: 200,
            responseText: JSON.stringify(
                responseJSON || {}
            )
    };
    return mockXHR;
}
</code></pre>

    <p>
      또 해당 데이터는 hook(beforeEach, afterEach)을 사용하여 윈도우 객체에 mock
      함수로 생성과 소멸 처리를 하였다.
    </p>

    <pre><code>beforeEach(() =&gt; {
    mockXHR = createMockXHR();
    window.XMLHttpRequest = jest.fn(() =&gt; mockXHR);
});
afterEach(() =&gt; {
    mockXHR = null;
    window.XMLHttpRequest = oldXMLHttpRequest;
});
</code></pre>

    <h2 id="4tdd">4. TDD를 통해 배운것</h2>

    <h3 id="41">4-1 테스트하기 좋은 코드</h3>

    <ul>
      <li>
        TDD를 통해 unit test를 하기 전 "좋은 코드는 응집도가 높고 결합도가
        낮아야 한다."라는 이야기를 깊이 이해하지 못했었다. 하지만 아주 작은
        단위를 테스트 하면서 함수 단위는 이전보다 더 작아졌고 하는 일이
        명확해졌다.
      </li>

      <li>
        "테스트 코드는 기능의 버그 유무를 판단한다."라는 것이 이번 프로젝트를
        진행하기 전에 테스트 코드에 대한 나의 지식 전부 였다. 하지만 테스트를
        염두하고 코드를 작성하면서 자연스럽게 리펙토링이 이루어졌다.
      </li>
    </ul>

    <h3 id="42">4-2 설계의 중요성</h3>

    <ul>
      <li>
        이전 프로젝트를 진행할 때는 설계의 중요성을 인지하지 못하고 깊은 고민
        없이 코드를 작성했다. 하지만 이번에 테스트 기반으로 프로젝트를
        진행하면서 깊게 고민하여 설계를 하고 테스트 목록을 만드는 것에 많은
        시간을 들였다. 결과적으로 코드를 작성하는 시간과 코드를 작성하면서
        겪었던 디버깅의 시간이 눈에 띄게 줄어들었다.
      </li>
    </ul>
  </body>
</html>
