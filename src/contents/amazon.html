<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Amazon Clone Project</title>
  <link rel="stylesheet" href="../style/style.css">
</head>

<body>
  <div class="project">
    <section class="project__header project__header--amazon">
      <h1 id="amazonclone">amazon clone</h1>
    </section>
    <section class="project__wrapper">
      <section class="project__group">
        <h2 id="1skills">1. Skills</h2>
        <p>HTML | SCSS | Javascript | webpack | Jest</p>
      </section>
      <section class="project__group">
        <h2 id="2">2. 개발 방식</h2>
        <p>레벨 2의 마지막 프로젝트인 amazon-clone를 시작하면서 두 가지를 목표로 삼았습니다.</p>
        <ol>
          <li><strong>지난 프로젝트에서 시도했던 방식 중 좋았던 부분을 더욱 발전시킨다.</strong></li>
          <li><strong>시도했던 방식 중 장점을 깨닫지 못했던 부분에 대해서 더 깊이 이해하기 위해 새로운 방식으로 적용한다.</strong></li>
        </ol>
        <h3 id="21">2-1 좋았던 방식</h3>
        <p>지난 프로젝트에서 비동기 데이터를 받는 부분에 대해서 for await of를 사용하여 이터러블한 코드를 구현하였다. 비동기 코드에 대해서 콜백으로 처리를 했던 방식(실질적으로 비동기를 처리하는
          방식은 아니지만)에서 promise를 활용한 비동기 처리 방식이 더 실용적으로 느껴졌다. 좋았던 이유는 가독성 부분이나 콜백 중첩을 만들지 않는다는 점도 있지만 무엇보다 제어권을 가져올 수 있다는
          것에 큰 매력을 느꼈다. 그래서 이번 프로젝트에서도 promise를 활용한 비동기 제어를 하기로 결정했다.</p>
        <h3 id="22">2-2 더 깊이 이해하고 싶었던 것</h3>
        <p>지난 프로젝트의 마지막 스텝은 '<strong>테스트 코드 작성'</strong>이었습니다. 기존에 작성된 프로젝트 코드를 unit test 하면서 버그 없이 정상적으로 작동 하는지를 체크하는
          과정을 경험하였습니다. 하지만 ~~사실 테스트 코드를 작성하는 시기엔 이 과정이 마냥 귀찮고 들이는 시간 대비 장점이 있는지 알 수 없었습니다...~~ 테스트 코드를 작성하면서 이 과정에 대한
          이점이 무엇인지 알기 위해서 테스트 코드에 관한 글, 책, 영상을 찾아보았습니다. 그 과정에서 많은 사람들이 견고한 소프트웨어를 만들기 위해서 반드시 필요한 것이라는 글을 쓰고 말을 하는 것을 읽고
          보았습니다. 그리고 기존 프로젝트가 마무리되고 새로운 프로젝트를 시작하는 시기에 테스트 코드의 진정한 장점이 무엇인지, 어떻게 작성해야 하는 것인지 더 깊이 알기 위해 자료를 찾아보았습니다. 이
          시기에 처음으로 TDD(Test Driven-Developement)라는 개발 방식을 발견했습니다. 테스트 코드를 작성한 후 실제 서비스 코드를 작성하는 방식이 신기했습니다. 그 후 jasmine을
          활용한 자바스크립트 테스트 관련 책을 하나 골라서 2번 정도 정독했고 테스트 코드가 직접 쓰이는 예제들을 분석 하고 연습해 보았습니다. 어렴풋하게 테스트 라이브러리에 대한 이해를 하고 새로운
          프로젝트 코드를 작성하기 시작했습니다.</p>
      </section>
      <section class="project__group">
        <h2 id="3tdd">3. TDD</h2>
        <p>프로젝트를 시작하면서 가장 먼저 한 일은 테스트 목록을 고민하는 것이었습니다. 어떤 테스트를 해야 할지를 고민하며 설계에 오랜 시간을 보냈습니다. 노트에 클래스 간의 의존 관계를 정의하고 각
          클래스의 하는 일을 명확하게 설정했습니다. 이 과정을 보낸 후 테스트 코드를 작성하였습니다. 클래스가 정상적으로 생성 되는지, 함수에 원하는 타입의 인자와 반환 값이 입력되고 반환 되는지 , 콜백
          함수가 정상적으로 실행 하는지... 그 모든 것들을 다 커버하기 위해 노력했습니다. <strong>작업을 이어가면서 가장 처음 느낀 것은 의미없는 테스트 코드를 너무 많이 작성한다는
            것이었습니다.</strong> 이 시기에 모듈 간의 의존성은 낯선 개념 이었기 때문에 중복 코드가 많았고 하드 코딩으로 작성된 코드가 많았습니다. 리펙토링을 해야겠다는 생각을 한 후 가장 먼저
          신경 썼던 부분은 타입 검사 테스트 부분이었습니다. 그래서 타입 체크 시스템을 만들 생각을 하게 되었습니다.</p>
        <h3 id="31typesystem">3-1 Type system</h3>
        <p>타입 스크립트를 쓸 수도 있었겠지만 레벨 2까지는 최대한 라이브러리를 사용하지 않고 자바스크립트 언어에 대한 더 깊은 이해를 하고 싶었습니다. 기능을 구현하기 위해 설계를 시작했습니다. 클래스
          간의 의존 관계를 명확히 파악하고 각 클래스가 수행하는 기능이 무엇인지 명확히 설정하는 것이 매우 중요했습니다. 타입을 체크하는 과정에는 다음과 같은 세가지 클래스가 필요했습니다. </p>
        <ol>
          <li><strong>실제 서비스에 사용될 코드가 정의된 클래스</strong></li>
          <li><strong>해당 클래스의 타입을 정의 해두는 클래스</strong></li>
          <li><strong>두번째 클래스에 입력된 인자 값과 반환 값이 세번째 클래스에 정의된 타입과 같은지 비교해주는 클래스</strong></li>
        </ol>
        <p>이렇게 세가지 클래스를 만들고 인자 값과 반환 값을 비교하여 정의한 타입이 올바르게 입출력 되는지를 체크했다. </p>
        <h3 id="32ui">3-2 UI 테스트</h3>
        <p>타입 체크 시스템 구현은 어려운 일이었지만 그만큼 UI 테스트를 하는 것도 신경쓰이는 부분이었습니다. 처음엔 브라우저가 아닌 노드 환경에서 작동하는 코드로 어떻게 UI 테스트를 할 지 감도
          안잡혔습니다. 그러던 중 '<strong>jsdom</strong>' 라이브러리를 발견했습니다. 이 라이브러리의 기능은 노드 환경에서 DOM의 환경을 구성할 수 있게 도와주는 것이었습니다. 이를
          통해 테스트 코드에서 DOM의 변화를 체크 할 수 있었습니다.</p>
        <p>node 환경에서 돔 핸들링은 아래에 작성된 유틸 역할을 하는 render 함수를 이용하여 해결할 수 있었습니다.</p>
        <pre><code>// test utill
  import {JSDOM} = require('jsdom');
  import window = new JSDOM();
  
  document = window.document;
  
  function render(html){
      const container = document.createElement("body");
      constainer.innerHtml = html;
      const $getTestEl = document.querySelector(`[data-testid="${testId}"]`);
      const $getTestElAll = document.querySelectorAll(`[data-testid="${testId}"]`);
      return {container, $getTestEl, $getTestElAll}
  }
  export {render};
  </code></pre>
        <h3 id="33asynchronousprocessing">3-3 Asynchronous processing</h3>
        <p>비동기 상황을 테스트하기 위해선 HTTP 데이터가 필요했습니다. 그래서 HTTP mock 객체를 사용해서 비동기 로직이 정상적으로 작동하는지 확인할 수 있었습니다.</p>
        <p>아래 코드는 Mock HTTP를 정의한 코드입니다.</p>
        <pre><code>const createMockXHR = (responseJSON) =&gt; {
      const mockXHR = {
              open: jest.fn(),
              send: jest.fn(),
              readyState: 4,
              status: 200,
              responseText: JSON.stringify(
                  responseJSON || {}
              )
      };
      return mockXHR;
  }
  </code></pre>
        <p>또 해당 데이터는 hook(beforeEach, afterEach)을 사용하여 윈도우 객체에 mock 함수로 생성과 소멸 처리를 하였습니다.</p>
        <pre><code>beforeEach(() =&gt; {
      mockXHR = createMockXHR();
      window.XMLHttpRequest = jest.fn(() =&gt; mockXHR);
  });
  afterEach(() =&gt; {
      mockXHR = null;
      window.XMLHttpRequest = oldXMLHttpRequest;
  });
  </code></pre>
      </section>
      <section class="project__group">
        <h2 id="4tdd">4. TDD를 통해 배운것</h2>
        <h3 id="41">4-1 테스트하기 좋은 코드</h3>
        <ul>
          <li>TDD를 통해 unit test를 하기 전 "좋은 코드는 응집도가 높고 결합도가 낮아야 한다."라는 이야기를 깊이 이해하지 못했었습니다. 하지만 아주 작은 단위를 테스트 하면서 함수 단위는
            이전보다 더 작아졌고 하는 일이 명확해졌습니다.</li>
          <li>"테스트 코드는 기능의 버그 유무를 판단한다."라는 것이 이번 프로젝트를 진행하기 전에 테스트 코드에 대한 나의 지식 전부 였습니다. 하지만 테스트를 염두하고 코드를 작성하면서 자연스럽게
            리펙토링이 이루어졌습니다.</li>
        </ul>
        <h3 id="42">4-2 설계의 중요성</h3>
        <ul>
          <li>이전 프로젝트를 진행할 때는 설계의 중요성을 인지하지 못하고 깊은 고민 없이 코드를 작성했습니다. 하지만 이번에 테스트 기반으로 프로젝트를 진행하면서 깊게 고민하여 설계를 하고 테스트 목록을
            만드는 것에 많은 시간을 들였습니다. 결과적으로 코드를 작성하는 시간과 코드를 작성하면서 겪었던 디버깅의 시간이 눈에 띄게 줄어들었습니다.</li>
        </ul>
      </section>
    </section>
  </div>
</body>

</html>