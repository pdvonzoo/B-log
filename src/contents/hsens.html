<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>H-SENS Project</title>
  <link rel="stylesheet" href="../style/style.css">
</head>

<body class="project">
  <section class="project__header project__header--hsens">
    <h1 id="hsens">H-SENS</h1>
  </section>
  <section class="project__wrapper">
    <section class="project__group">
      <h2 id="1skills">1. Skills</h2>
      <p>Styled Component | React(Hooks) | GraphQL | Apollo | Node.js | MongoDB</p>
    </section>
    <section class="project__group">
      <h2 id="2">2. 개발 방식</h2>
      <p>이번 프로젝트는 다음 세 가지에 초점을 맞췄습니다.</p>
      <ol>
        <li><strong>협업 프로세스에 대한 깊은 경험을 한다.</strong></li>
        <li><strong>설계에 신경 쓴 프론트 엔드 코드를 작성하자.</strong></li>
        <li><strong>백엔드 코드를 구현하여 HTTP 통신에 대해서 더 깊이 이해하도록 노력한다.</strong></li>
      </ol>
      <p>두 명으로 구성된 팀으로 개발한 프로젝트이며 github를 사용해서 개발을 진행하였습니다.</p>
      <h3 id="21">2-1 협업</h3>
      <ul>
        <li><strong>회의 및 프로젝트 기본 개요</strong>: Wiki를 사용하여 진행하였습니다.</li>
        <li><strong>업무 분담</strong>: issues 탭에 milestone을 추가하고 해당 내용에 해당하는 세부적인 내용은 issue를 추가하여 관리하였습니다.</li>
        <li><strong>업무 진행 상황</strong>: project에 todo List를 추가하여 관리하였습니다.</li>
        <li><strong>Sprint</strong>: 스프린트 단위는 1주를 기본으로 하고 이후에 feature branch를 dev branch에 머지했습니다. 이후 버전 별로 릴리즈를 하여 태그를
          추가하였습니다.</li>
        <li><strong>Commutication:</strong> 리모트 형식으로 작업을 진행하였고 slack을 이용하였습니다.</li>
      </ul>
      <h3 id="22client">2-2 Client</h3>
      <ul>
        <li><strong>설계</strong></li>
      </ul>
      <p>이번 프로젝트에서 TDD를 사용하지는 않았지만 지난 amazon project를 진행 하며 설계의 중요성을 깨달았고 이번 프로젝트도 그렇게 진행하고 싶었습니다. 프로젝트를 시작한 첫 주는 설계에
        초점을 둔 기획회의의 연속이었습니다. 노트, 화이트보드에 <strong>컴포넌트 간 의존 관계</strong>를 그리고 연결 해보았습니다. 또 서비스에 필요한 기능을 구체화 했습니다. </p>
      <ul>
        <li><strong>디자인</strong></li>
      </ul>
      <p>주제와 컨셉이 정해진 후 개발 방식에 대해서 고민해 보았습니다. 디자인에 대해서 많은 시간을 투자하기 힘든 상황이었기 때문에 페이지 별 기능을 정의하고 큰 맥락에서 컴포넌트 간의 의존관계를 정의한 후
        코드를 작성하면서 레이이웃을 잡아갔습니다. </p>
      <h3 id="23server">2-3 Server</h3>
      <ul>
        <li><strong>설계</strong></li>
      </ul>
      <p>프론트엔드 설계를 완료한 후 백엔드 설계를 시작하였습니다. 각 컴포넌트 별로 필요한 데이터를 정리하고 해당 데이터에 따른 Router를 만들었습니다. 초기엔 Restful API를 지향했지만 이후
        GraphQL을 사용하여 재정의 하였습니다. </p>
      <ul>
        <li><strong>데이터베이스</strong></li>
      </ul>
      <p>No-SQL기반의 Mongodb를 사용했습니다. 프론트엔드 개발자이기에 데이터베이스에 대한 이론 지식이 부족해서 해당 데이터베이스의 장점을 파악하며 DB를 설계하기 위해 노력했습니다. </p>
    </section>
    <section class="project__group">
      <h2 id="3">3. 협업 관련 세부사항</h2>
      <h3 id="31">3-1 협업 관련 커뮤니케이션</h3>
      <p>리모트 형식으로 개발을 진행했기 때문에 이 부분에 굉장히 중요했습니다. 협업 관련 툴은 slack과 github를 사용했습니다. </p>
      <ul>
        <li>slack: 프로젝트 관련 작은 부분들에 대한 이야기를 나눌때 slack을 통해 커뮤니케이션을 하였습니다.</li>
        <li>github <ul>
            <li>issues: mileston을 정의하고 각자 해야 하는 작업에 대해서 github의 issues 탭을 사용했습니다. 해결된 이슈에 대해서는 close하기 전 commit id를 적어
              두어 프로젝트 진행 로그를 남겼습니다.</li>
            <li>project: github의 project 탭을 사용하여 todo를 정의하였습니다. issues와 관련된 작업들을 시각화하기 위해 사용하였습니다.</li>
            <li>wiki: 회의록과 프로젝트 관련 정의를 하기 위해서 wiki 탭을 사용하였습니다. 프로젝트에 관련된 정의들을 적어 두었기 때문에 이후 프로젝트 진행을 하면서 지난 기록들을 보면서 작업을
              진행하기에 좋았습니다.</li>
          </ul>
        </li>
      </ul>
      <h3 id="32sprint">3-2 sprint</h3>
      <p>1주 단위로 sprint를 나눴습니다. 매 주 sprint+해당 주 차(예, sprint1)의 브랜치를 만들었습니다. 또 금요일에 해당 주에 각자의 issues를 마무리하고 회고를 한 뒤 dev
        브랜치에 머지한 후 릴리즈를 하여 tag를 추가했습니다. </p>
    </section>
    <section class="project__group">
      <h2 id="4client">4. Client 관련 세부사항</h2>
      <h3 id="41">4-1 컴포넌트 설계</h3>
      <p>컴포넌트를 나누는 방식에 대한 많은 고민이 있었는데요. 많은 고민을 했던 부분이기 때문에 세 번의 변경이 있었습니다. </p>
      <p><strong>1) 모든 컴포넌트를 Component 폴더에 넣고 Router 파일을 정의하기</strong></p>
      <p>모든 page에 대한 컴포넌트에서 버튼 같이 작은 컴포넌트까지 모든 파일을 Component 폴더에 정의하였습니다. 또 router관련한 정의는 router 파일에 모두 작성하였습니다. 이렇게
        정의하는 것에 대해서 고민이 생겼습니다. state관리를 하는 컴포넌트의 크기가 너무 커진다는 것이었습니다. 이 방식을 해결하기 위해서 구글링을 하였고 Presenter, Container로 역할을
        나눈 컴포넌트 설계 방식을 찾게 되었습니다. </p>
      <p><strong>2) Component 폴더 내부를 Presenter, Container 폴더로 나누기</strong></p>
      <p>Component 폴더 내부에 모든 파일들의 두 가지 분류로 나눴습니다. state를 관리하는 컴포넌트는 Container 폴더로, 템플릿 관련 기능을 하는 컴포넌트는 Presenter에 두었습니다.
        처음 폴더 구조를 재 설정하여 코드를 작성할 때는 순조로웠습니다. 하지만 시간이 지날 수록 같은 일을 하는 컴포넌트 간의 거리가 멀어서 리펙토링이 불편했고 굳이 깊이를 한 단계 더 만드는 것이
        불필요하다는 생각이 들었습니다. </p>
      <p><strong>3) Router 기분으로 컴포넌트 나누기</strong></p>
      <p>기존의 Container 폴더와 Presenter 폴더를 제거하였습니다. Router 기준으로 컴포넌트를 생성하였습니다. 페이지 별로 컴포넌트를 만들고 재사용의 가치가 있는 컴포넌트들을 따로
        구성하였습니다. 맨 처음 설계한 <strong>1)</strong> 구조와 비슷했지만 차이가 있습니다. 새롭게 변경한 설계에서는 각 컴포넌트에서 state 관리로 인하여 파일이 크기가 커진 상황이 오면
        그 컴포넌트 내부의 파일에 대해서 state 관리를 하는 Container 역할의 컴포넌트, 템플레이팅 기능을 하는 Presenter 컴포넌트로 나눴습니다. 결과적으로 컴포넌트의 역할이 더 명확해졌고
        컴포넌트의 응집성이 높아졌습니다. </p>
      <h3 id="42state">4-2 state 관리</h3>
      <p>state 관리에 대해서도 세 번의 변경이 있었습니다. </p>
      <p><strong>1) useState, useEffect</strong></p>
      <p>Hooks로 개발을 시작했기 때문에 시작은 useState와 useEffect를 사용하여 state를 관리하였습니다. 처음엔 해당 메서드로 state 관리를 해도 충분했지만 컴포넌트의 depth가
        깊어지자 점점 관리하기 복잡한 부분이 생겨났습니다. props의 전달에 복잡함에 flux architecture를 활용하기로 했습니다. </p>
      <p><strong>2) useContext, useReducer</strong></p>
      <p>action, store, dispatch의 역할을 통해 state를 전역에서 관리하는 Flux Architecture의 방식을 활용하여 action을 정의하고 useContext로 store을
        만들고 useReducer를 dispatch로 사용하였습니다. 이 방식을 사용하며 state 관리을 간소화 하였습니다. 하지만 이 작업을 마친 후 restful API를 통해 정의하는 과정에서
        url관리의 복잡함을 느꼈기 때문에 GraphQL을 도입하게 되었습니다. </p>
      <p><strong>3) Apollo Client Server</strong></p>
      <p>GraphQL을 사용하며 전역에서 사용하는 state 관리는 Apollo client을 활용하기로 하였습니다. authontication관련 state를 apollo client state에 정의하여
        서비스 전역에서 사용하였습니다. 결과적으로 서버와의 통신은 더 간소화 되었고 Client에서 쿼리를 정의하여 버그가 더 줄어들었고 state 관리도 가벼워졌습니다. </p>
    </section>
    <section class="project__group">
      <h2 id="5server">5. Server 관련 세부사항</h2>
      <h3 id="51restfulapiapolloserver">5-1 RestFul API → Apollo Server</h3>
      <p>Restful API를 지향하는 API server를 작성하였습니다. 라우터를 만들고 각 라우터별로 http method에 따른 요청,응답을 정의 하였습니다. 작업이 많이 진행되는 상황에서
        GraphQL로 바꾸게 되었습니다. 그 이유는 많은 라우터를 관리하는 것에 대한 불편함과 Query를 client에서도 정의하여 버그를 최소화 할 수 있을것 같았기 때문이었습니다. 생각했던 대로 메소드
        단위로 정의하는 Graphql QL의 코드는 더욱 간결해졌고 client에서 타입을 정의하여서 더욱 안전한 코드를 작성할 수 있었습니다. </p>
      <h3 id="52authentication">5-2 Authentication</h3>
      <p>json web token을 사용하여 인증을 구현하였습니다. html5 webstorage인 localstorage에 token을 저장하고 인증하는 로직을 구현하였습니다.</p>
    </section>
  </section>
</body>

</html>